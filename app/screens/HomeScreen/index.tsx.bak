import React, {
  useCallback,
  useState,
  useRef,
  useEffect,
  useMemo,
} from "react";
import {
  View,
  Text,
  TouchableOpacity,
  InteractionManager,
  Image,
  ScrollView,
  Dimensions,
  Platform,
  StatusBar,
  SafeAreaView,
  Alert,
  ActivityIndicator,
} from "react-native";
import { Image as ExpoImage } from "expo-image";
import { LinearGradient } from "expo-linear-gradient";
import {
  productApi,
  type Product,
  type Category,
} from "../../services/api/productApi";
import Ionicons from "@expo/vector-icons/Ionicons";
import { useNavigation } from "@react-navigation/native";
import { NativeStackNavigationProp } from "@react-navigation/native-stack";
import { useTranslation } from "react-i18next";
import i18n from "../../i18n";
import useUserStore from "../../store/user";
import { launchImageLibrary, launchCamera, MediaType, ImagePickerResponse, ImageLibraryOptions, CameraOptions } from 'react-native-image-picker';
import { useGlobalStore } from "../../store/useGlobalStore";
import AsyncStorage from "@react-native-async-storage/async-storage";
import { getCategoryImageSource } from "../../utils/categoryImageUtils";
import { eventBus } from "../../utils/eventBus";

// å¯¼å…¥æ‹†åˆ†çš„ç»„ä»¶
import {
  SearchBar,
  MultiPageContainer,
} from "./components";

// å¯¼å…¥æ ·å¼
import { styles, loginModalStyles } from "./styles";

// å¯¼å…¥è‡ªå®šä¹‰ hook
import { useMultiPageData } from "./hooks/useMultiPageData";

type IconProps = {
  name: string;
  size: number;
  color: string;
};

const IconComponent = React.memo(({ name, size, color }: IconProps) => {
  const Icon = Ionicons as any;
  return <Icon name={name} size={size} color={color} />;
});

export const HomeScreen = () => {
  const navigation = useNavigation<NativeStackNavigationProp<any>>();
  const { t } = useTranslation();
  const userStore = useUserStore();
  const { country, currency } = useGlobalStore();
  const horizontalScrollRef = useRef<ScrollView>(null);
  
  // ç¼“å­˜ç”¨æˆ·ç›¸å…³æ•°æ®ï¼Œé¿å…ä¸å¿…è¦çš„é‡æ–°æ¸²æŸ“
  const memoizedUserStore = useMemo(() => ({
    user: userStore.user,
  }), [userStore.user]);

  // è·å–æ­£ç¡®è¯­è¨€çš„ç±»ç›®åç§°
  const getCategoryName = useCallback((category: Category) => {
    const currentLanguage = i18n.language;
    switch(currentLanguage) {
      case 'en':
        return category.name_en || category.name;
      case 'fr':
        return category.name;
      case 'cn':
      case 'zh':
        return category.name_cn || category.name;
      default:
        return category.name;
    }
  }, []);

  // å­˜å‚¨æ¯ä¸ªåˆ†ç±»æŒ‰é’®çš„å®½åº¦ä¿¡æ¯
  const categoryWidthsRef = useRef<Map<number, number>>(new Map());
  const categoryPositionsRef = useRef<Map<number, number>>(new Map());
  const isScrollingRef = useRef(false); // é˜²æ­¢é‡å¤æ»šåŠ¨çš„æ ‡å¿—ä½

  // ç»„ä»¶æŒ‚è½½æ—¥å¿—
  useEffect(() => {
    console.log('[HomeScreen] Component mounted', {
      timestamp: new Date().toISOString(),
      hasUser: !!userStore.user?.user_id
    });
    
    return () => {
      console.log('[HomeScreen] Component will unmount', {
        timestamp: new Date().toISOString()
      });
    };
  }, []);

  // åŠ è½½ç”¨æˆ·æ˜¯å¦å·²å…³é—­è¿‡ç™»å½•å¼¹çª—çš„çŠ¶æ€
  useEffect(() => {
    const loadDismissedLoginModalState = async () => {
      try {
        const dismissed = await AsyncStorage.getItem('@login_modal_dismissed');
        if (dismissed === 'true') {
          setHasUserDismissedLoginModal(true);
        }
      } catch (error) {
        console.error('åŠ è½½ç™»å½•å¼¹çª—å…³é—­çŠ¶æ€å¤±è´¥:', error);
      }
    };
    loadDismissedLoginModalState();
  }, []);


  
  // æœ¬åœ°çŠ¶æ€
  const [showImagePickerModal, setShowImagePickerModal] = useState(false);
  const [selectedCategoryId, setSelectedCategoryId] = useState<number>(-1); // -1 è¡¨ç¤ºæ¨èé¡µ
  const [galleryUsed, setGalleryUsed] = useState(false);
  const [showLoginModal, setShowLoginModal] = useState(false); // ä¸ä¾èµ–userStoreåˆå§‹åŒ–ï¼Œåœ¨useEffectä¸­å¤„ç†
  const [hasUserDismissedLoginModal, setHasUserDismissedLoginModal] = useState(false); // ç”¨æˆ·æ˜¯å¦å·²å…³é—­è¿‡ç™»å½•å¼¹çª—

  // è°ƒè¯•selectedCategoryIdå˜åŒ–
  useEffect(() => {
    console.log('[HomeScreen] selectedCategoryId changed to:', selectedCategoryId, {
      timestamp: new Date().toISOString()
    });
  }, [selectedCategoryId]);

  // ç›‘å¬å¯¼èˆªåˆ°æ¨èé¡µçš„äº‹ä»¶
  useEffect(() => {
    const handleNavigateToRecommend = () => {
      console.log('[HomeScreen] Navigating to recommend page');
      setSelectedCategoryId(-1); // -1 è¡¨ç¤ºæ¨èé¡µ
    };

    eventBus.on('navigateToRecommend', handleNavigateToRecommend);

    return () => {
      eventBus.off('navigateToRecommend', handleNavigateToRecommend);
    };
  }, []);

  // åˆ†ç±»ç›¸å…³çŠ¶æ€
  const [categories, setCategories] = useState<Category[]>([]);
  const [subcategories, setSubcategories] = useState<Category[]>([]);
  const [subcategoriesLoading, setSubcategoriesLoading] = useState(false);
  const [showAllSubcategories, setShowAllSubcategories] = useState(false);
  const [showCategoryModal, setShowCategoryModal] = useState(false);

  // ä½¿ç”¨å¤šé¡µé¢æ•°æ®ç®¡ç†hook
  const {
    getPageData,
    loadPageData,
    refreshPageData,
    loadMoreData,
    preloadAdjacentPages,
    cleanupPageData,
    allCategories,
  } = useMultiPageData(categories);

  // è®°å½•åˆ†ç±»æŒ‰é’®çš„ä½ç½®ä¿¡æ¯
  const handleCategoryLayout = useCallback((categoryId: number, event: any) => {
    const { x, width } = event.nativeEvent.layout;
    categoryWidthsRef.current.set(categoryId, width);
    categoryPositionsRef.current.set(categoryId, x);
  }, []);

  // ç²¾ç¡®å±…ä¸­å½“å‰é€‰ä¸­çš„åˆ†ç±»
  const scrollCategoryToCenter = useCallback((categoryId: number, immediate = false) => {
    if (!horizontalScrollRef.current || isScrollingRef.current) return;
    
    const executeScroll = () => {
      const position = categoryPositionsRef.current.get(categoryId);
      const width = categoryWidthsRef.current.get(categoryId);
      
      if (position !== undefined && width !== undefined) {
        const screenWidth = Dimensions.get('window').width;
        const containerPadding = 10; // categoryScrollçš„paddingHorizontal
        
        // è®¡ç®—ç›®æ ‡åˆ†ç±»çš„ä¸­å¿ƒç‚¹ä½ç½®
        const itemCenterX = position + (width / 2);
        
        // è®¡ç®—éœ€è¦æ»šåŠ¨çš„è·ç¦»ï¼Œä½¿åˆ†ç±»å±…ä¸­æ˜¾ç¤º
        const scrollToX = Math.max(0, itemCenterX - (screenWidth / 2) + containerPadding);
        
        isScrollingRef.current = true;
        horizontalScrollRef.current?.scrollTo({
          x: scrollToX,
          animated: !immediate,
        });
        
        // é‡ç½®æ»šåŠ¨æ ‡å¿—ä½
        setTimeout(() => {
          isScrollingRef.current = false;
        }, immediate ? 0 : 300);
      } else {
        // å¦‚æœè¿˜æ²¡æœ‰å¸ƒå±€ä¿¡æ¯ï¼Œä½¿ç”¨ç®€å•ä¼°ç®—
        const categoryIndex = allCategories.findIndex(cat => cat.category_id === categoryId);
        if (categoryIndex !== -1) {
          const estimatedItemWidth = 80;
          const screenWidth = Dimensions.get('window').width;
          const scrollToX = Math.max(0, (categoryIndex * estimatedItemWidth) - (screenWidth / 2));
          
          isScrollingRef.current = true;
          horizontalScrollRef.current?.scrollTo({
            x: scrollToX,
            animated: !immediate,
          });
          
          // é‡ç½®æ»šåŠ¨æ ‡å¿—ä½
          setTimeout(() => {
            isScrollingRef.current = false;
          }, immediate ? 0 : 300);
        }
      }
    };
    
    if (immediate) {
      executeScroll();
    } else {
      // åªåœ¨æœ‰å¸ƒå±€ä¿¡æ¯æ—¶æ‰å»¶è¿Ÿï¼Œå¦åˆ™ç«‹å³æ‰§è¡Œ
      const hasLayoutInfo = categoryPositionsRef.current.has(categoryId);
      if (hasLayoutInfo) {
        executeScroll();
      } else {
        setTimeout(executeScroll, 50);
      }
    }
  }, [allCategories]);

  // åˆ‡æ¢ç±»ç›®çš„å‡½æ•°
  const handleCategoryChange = useCallback((categoryId: number) => {
    // å¦‚æœcategoryIdç›¸åŒï¼Œé¿å…é‡å¤æ‰§è¡Œ
    if (categoryId === selectedCategoryId) {
      return;
    }
    
    console.log(`[HomeScreen] handleCategoryChange called - categoryId: ${categoryId}`);
    setSelectedCategoryId(categoryId);
    
    // ä½¿ç”¨requestAnimationFrameç¡®ä¿åœ¨ä¸‹ä¸€å¸§æ‰§è¡Œæ»šåŠ¨ï¼Œé¿å…å†²çª
    requestAnimationFrame(() => {
      scrollCategoryToCenter(categoryId);
    });
    
    // ä¸ºæ¨èé¡µé¢å’Œåˆ†ç±»é¡µé¢è‡ªåŠ¨åŠ è½½æ•°æ®
    if (categoryId === -1 || categoryId > 0) {
      const pageData = getPageData(categoryId);
      
      // å¦‚æœé¡µé¢æ²¡æœ‰åˆå§‹åŒ–æˆ–è€…æ²¡æœ‰äº§å“æ•°æ®ï¼Œåˆ™åŠ è½½æ•°æ®
      if (!pageData.initialized || pageData.products.length === 0) {
        console.log(`[HomeScreen] è§¦å‘loadPageData - categoryId: ${categoryId}`);
        loadPageData(categoryId);
      }
    }
    
    // å»¶è¿Ÿæ¸…ç†æ•°æ®ï¼Œç¡®ä¿é¡µé¢åˆ‡æ¢å®Œæˆ
    setTimeout(() => {
      cleanupPageData(categoryId);
    }, 100);
  }, [selectedCategoryId, scrollCategoryToCenter, getPageData, loadPageData, cleanupPageData]);

  // å¤„ç†äº§å“ç‚¹å‡»
  const handleProductPress = useCallback(
    (item: Product) => {
      InteractionManager.runAfterInteractions(() => {
        navigation.navigate("ProductDetail", {
          offer_id: item.offer_id,
          price: item.min_price,
        });
      });
    },
    [navigation],
  );

  // å¤„ç†äºŒçº§åˆ†ç±»ç‚¹å‡»
  const handleSubcategoryPress = useCallback(
    (subcategoryId: number) => {
      console.log(`[HomeScreen] äºŒçº§åˆ†ç±»ç‚¹å‡» - subcategoryId: ${subcategoryId}`);
      InteractionManager.runAfterInteractions(() => {
        navigation.navigate("SearchResult", {
          category_id: subcategoryId,
        });
      });
    },
    [navigation],
  );

  // å¤„ç†æŸ¥çœ‹å…¨éƒ¨äºŒçº§åˆ†ç±»
  const handleViewAllSubcategories = useCallback(
    (categoryId: number) => {
      console.log(`[HomeScreen] æŸ¥çœ‹å…¨éƒ¨äºŒçº§åˆ†ç±» - categoryId: ${categoryId}`);
      InteractionManager.runAfterInteractions(() => {
        // å¯ä»¥å¯¼èˆªåˆ°ä¸“é—¨çš„äºŒçº§åˆ†ç±»é¡µé¢ï¼Œæˆ–è€…æ˜¾ç¤ºå¼¹çª—
        // è¿™é‡Œç¤ºä¾‹å¯¼èˆªåˆ°æœç´¢ç»“æœé¡µé¢ï¼Œæ˜¾ç¤ºè¯¥ä¸€çº§åˆ†ç±»ä¸‹çš„æ‰€æœ‰äº§å“
        navigation.navigate("SearchResult", {
          category_id: categoryId,
        });
      });
    },
    [navigation],
  );

  // å¤„ç†ç›¸æœºæŒ‰é’®ç‚¹å‡»
  const handleCameraPress = useCallback(() => {
    setShowImagePickerModal(true);
  }, []);

  // å¤„ç†å…³é—­ç™»å½•å¼¹çª—
  const handleDismissLoginModal = useCallback(async () => {
    setShowLoginModal(false);
    setHasUserDismissedLoginModal(true);
    try {
      await AsyncStorage.setItem('@login_modal_dismissed', 'true');
      console.log('[HomeScreen] ç”¨æˆ·å…³é—­ç™»å½•å¼¹çª—ï¼Œå·²ä¿å­˜çŠ¶æ€');
    } catch (error) {
      console.error('ä¿å­˜ç™»å½•å¼¹çª—å…³é—­çŠ¶æ€å¤±è´¥:', error);
    }
  }, []);

  // å›¾ç‰‡é€‰æ‹©å™¨ç›¸å…³å‡½æ•°
  const cleanupImagePickerCache = async () => {
    try {
      console.log("react-native-image-picker è‡ªåŠ¨ç®¡ç†ç¼“å­˜");
      setGalleryUsed(false);
    } catch (error) {
      console.log("æ¸…ç†ç¼“å­˜é”™è¯¯", error);
      setGalleryUsed(false);
    }
  };

  const handleChooseFromGallery = useCallback(async () => {
    setShowImagePickerModal(false);
    setTimeout(async () => {
      try {
        const options: ImageLibraryOptions = {
          mediaType: 'photo' as MediaType,
          includeBase64: false,
          maxHeight: 2000,
          maxWidth: 2000,
          quality: 1,
        };
        
        launchImageLibrary(options, (response: ImagePickerResponse) => {
          if (response.didCancel) {
            console.log('ç”¨æˆ·å–æ¶ˆäº†å›¾ç‰‡é€‰æ‹©');
            return;
          }
          
          if (response.errorMessage) {
            console.log('ç›¸å†Œé”™è¯¯:', response.errorMessage);
            return;
          }
          
          if (response.assets && response.assets.length > 0) {
            const asset = response.assets[0];
            if (asset.uri) {
              navigation.navigate("ImageSearchResultScreen", {
                image: asset.uri,
                type: 1,
              });
            }
          }
        });
      } catch (error) {
        console.error("ç›¸å†Œé”™è¯¯:", error);
        await cleanupImagePickerCache();
      }
    }, 500);
  }, [navigation, t]);

  const handleTakePhoto = useCallback(async () => {
    setShowImagePickerModal(false);
    setTimeout(async () => {
      try {
        const options: CameraOptions = {
          mediaType: 'photo' as MediaType,
          includeBase64: false,
          maxHeight: 2000,
          maxWidth: 2000,
          quality: 1,
        };
        
        launchCamera(options, (response: ImagePickerResponse) => {
          if (response.didCancel) {
            console.log('ç”¨æˆ·å–æ¶ˆäº†æ‹ç…§');
            return;
          }
          
          if (response.errorMessage) {
            console.log('ç›¸æœºé”™è¯¯:', response.errorMessage);
            return;
          }
          
          if (response.assets && response.assets.length > 0) {
            const asset = response.assets[0];
            if (asset.uri) {
              navigation.navigate("ImageSearchResultScreen", {
                image: asset.uri,
                type: 1,
              });
            }
          }
        });
      } catch (error) {
        console.error("ç›¸æœºé”™è¯¯:", error);
        await cleanupImagePickerCache();
      }
    }, 500);
  }, [navigation, t]);

  const resetAppState = useCallback(() => {
    setGalleryUsed(false);
    cleanupImagePickerCache();
    Alert.alert(t('banner.inquiry.camera_reset'), t('banner.inquiry.camera_reset_message'));
  }, [t]);

  // è·å–ä¸€çº§ç±»ç›®å¹¶åˆå§‹åŒ–æ•°æ®ï¼ˆåªåœ¨ç»„ä»¶æŒ‚è½½æ—¶æ‰§è¡Œä¸€æ¬¡ï¼‰
  useEffect(() => {
    console.log('[HomeScreen] fetchCategories useEffect triggered', {
      timestamp: new Date().toISOString(),
      categoriesLength: categories.length
    });
    
    const fetchCategories = async () => {
      try {
        console.log('[HomeScreen] Calling getFirstCategory API');
        const res = await productApi.getFirstCategory();
        console.log('[HomeScreen] getFirstCategory API response:', res.length, 'categories');
        setCategories(res);
        
        // ä¸å†è‡ªåŠ¨åŠ è½½æ¨èæ•°æ®ï¼Œç­‰ç”¨æˆ·æ‰‹åŠ¨è§¦å‘
        // loadPageData(-1);
      } catch (e) {
        console.error("è·å–ä¸€çº§ç±»ç›®å¤±è´¥", e);
      }
    };
    fetchCategories();
  }, []); // åªåœ¨ç»„ä»¶æŒ‚è½½æ—¶æ‰§è¡Œä¸€æ¬¡

  // å½“åˆ†ç±»æ•°æ®åŠ è½½å®Œæˆåï¼Œè¿›è¡Œåˆå§‹å®šä½å¹¶åŠ è½½æ¨èæ•°æ®
  const hasInitializedRef = useRef(false);
  useEffect(() => {
    if (categories.length > 0 && !hasInitializedRef.current) {
      hasInitializedRef.current = true;
      setTimeout(() => {
        scrollCategoryToCenter(selectedCategoryId, true); // ä½¿ç”¨immediateæ¨¡å¼
        
        // åªåœ¨åˆå§‹åŒ–æ—¶è‡ªåŠ¨åŠ è½½æ¨èé¡µé¢æ•°æ®
        if (selectedCategoryId === -1) {
          const pageData = getPageData(-1);
          if (!pageData.initialized || pageData.products.length === 0) {
            console.log('[HomeScreen] ğŸš€ è‡ªåŠ¨åŠ è½½æ¨èé¡µé¢æ•°æ®', {
              timestamp: new Date().toISOString(),
              initialized: pageData.initialized,
              productsLength: pageData.products.length
            });
            loadPageData(-1);
          }
        }
      }, 150); // ç¨å¾®å¢åŠ å»¶è¿Ÿç¡®ä¿DOMå®Œå…¨æ›´æ–°
    }
  }, [categories.length]); // åªä¾èµ–categories.lengthï¼Œé¿å…selectedCategoryIdå˜åŒ–æ—¶é‡å¤è§¦å‘

  // è·å–äºŒçº§ç±»ç›® - ä½¿ç”¨é˜²æŠ–å¤„ç†
  const fetchSubcategoriesRef = useRef<NodeJS.Timeout>();
  useEffect(() => {
    // æ¸…é™¤ä¹‹å‰çš„è¯·æ±‚
    if (fetchSubcategoriesRef.current) {
      clearTimeout(fetchSubcategoriesRef.current);
    }
    
    if (selectedCategoryId > 0) {
      setSubcategoriesLoading(true);
      setShowAllSubcategories(false); // åˆ‡æ¢åˆ†ç±»æ—¶é‡ç½®å±•å¼€çŠ¶æ€
      
      // é˜²æŠ–å¤„ç†ï¼Œé¿å…å¿«é€Ÿåˆ‡æ¢æ—¶çš„å¤šæ¬¡è¯·æ±‚
      fetchSubcategoriesRef.current = setTimeout(async () => {
        try {
          const res = await productApi.getSecondCategory(selectedCategoryId);
          setSubcategories(res);
        } catch (e) {
          setSubcategories([]);
        } finally {
          setSubcategoriesLoading(false);
        }
      }, 300); // 300ms é˜²æŠ–
    } else {
      setSubcategories([]);
      setSubcategoriesLoading(false);
      setShowAllSubcategories(false);
    }
    
    return () => {
      if (fetchSubcategoriesRef.current) {
        clearTimeout(fetchSubcategoriesRef.current);
      }
    };
  }, [selectedCategoryId]);

  // ç›‘å¬ç™»å½•çŠ¶æ€å˜åŒ– - åˆ†ç¦»å…³æ³¨ç‚¹ï¼Œå‡å°‘ä¾èµ–
  const prevUserIdRef = useRef<number | undefined>();
  const selectedCategoryIdRef = useRef(selectedCategoryId);
  selectedCategoryIdRef.current = selectedCategoryId; // ä¿æŒrefæœ€æ–°
  
  useEffect(() => {
    const currentUserId = userStore.user?.user_id;
    const prevUserId = prevUserIdRef.current;
    
    // åªåœ¨ç”¨æˆ·IDçœŸæ­£å˜åŒ–æ—¶æ‰§è¡Œé€»è¾‘
    if (currentUserId !== prevUserId) {
      prevUserIdRef.current = currentUserId;
      
      if (currentUserId) {
        setShowLoginModal(false);
        setHasUserDismissedLoginModal(false);
        AsyncStorage.removeItem('@login_modal_dismissed').catch(console.error);
        
        // ç”¨æˆ·ä»æœªç™»å½•å˜ä¸ºç™»å½•çŠ¶æ€ï¼Œä¸”å½“å‰åœ¨æ¨èé¡µé¢
        if (!prevUserId && selectedCategoryIdRef.current === -1) {
          setTimeout(() => {
            console.log('[HomeScreen] ç”¨æˆ·ç™»å½•ååˆ·æ–°æ¨èæ•°æ®');
            refreshPageData(-1);
          }, 500);
        }
      } else if (!hasUserDismissedLoginModal) {
        setShowLoginModal(true);
      }
    }
  }, [userStore.user?.user_id, hasUserDismissedLoginModal, refreshPageData]); // ä¿ç•™ refreshPageData ä¾èµ–

  // ç›‘å¬è®¾ç½®å˜æ›´äº‹ä»¶ï¼Œå¼ºåˆ¶åˆ·æ–°é¦–é¡µæ•°æ® - ä½¿ç”¨ useCallback ä¼˜åŒ–
  const handleSettingsChanged = useCallback(() => {
    console.log('[HomeScreen] è®¾ç½®å‘ç”Ÿå˜æ›´ï¼Œå¼ºåˆ¶åˆ·æ–°é¦–é¡µæ•°æ®');
    
    // è·å–å½“å‰çš„ selectedCategoryId
    const currentCategoryId = selectedCategoryId;
    
    // å¼ºåˆ¶åˆ·æ–°å½“å‰é¡µé¢çš„æ•°æ®
    if (currentCategoryId === -1 || currentCategoryId > 0) {
      setTimeout(() => {
        console.log('[HomeScreen] åˆ·æ–°é¡µé¢æ•°æ®:', currentCategoryId);
        refreshPageData(currentCategoryId);
      }, 300);
    }
    
    // é‡æ–°è·å–ä¸€çº§ç±»ç›®ï¼ˆå¯èƒ½å› ä¸ºè¯­è¨€å˜æ›´éœ€è¦é‡æ–°è·å–ï¼‰
    setTimeout(async () => {
      try {
        console.log('[HomeScreen] é‡æ–°è·å–ä¸€çº§ç±»ç›®');
        const res = await productApi.getFirstCategory();
        setCategories(res);
      } catch (error) {
        console.error('[HomeScreen] é‡æ–°è·å–ä¸€çº§ç±»ç›®å¤±è´¥:', error);
      }
    }, 500);
  }, [selectedCategoryId, refreshPageData]);
  
  useEffect(() => {
    // ç›‘å¬è®¾ç½®å˜æ›´äº‹ä»¶
    eventBus.on('settingsChanged', handleSettingsChanged);
    eventBus.on('refreshSetting', handleSettingsChanged);
    
    // æ¸…ç†ç›‘å¬å™¨
    return () => {
      eventBus.off('settingsChanged', handleSettingsChanged);
      eventBus.off('refreshSetting', handleSettingsChanged);
    };
  }, [handleSettingsChanged]); // åªä¾èµ– handleSettingsChanged


  // æ¸²æŸ“åˆ†ç±»åŒºåŸŸï¼ˆæ€§èƒ½ä¼˜åŒ–ç‰ˆï¼‰
  const renderCategorySection = useMemo(
    () => (
      <View style={styles.category}>
        <View style={styles.categoryScrollContainer}>
          <ScrollView
            bounces={false}
            overScrollMode="never"
            ref={horizontalScrollRef}
            horizontal
            showsHorizontalScrollIndicator={false}
            style={styles.categoryScroll}
            removeClippedSubviews={true}
            scrollEventThrottle={16}
          >
            {/* æ¨èæŒ‰é’® */}
            <TouchableOpacity
              key="recommendations"
              style={[
                styles.categoryItem,
                selectedCategoryId === -1 && styles.categoryItemActive,
              ]}
              onPress={() => handleCategoryChange(-1)}
              onLayout={(event) => handleCategoryLayout(-1, event)}
            >
              <Text
                style={[
                  styles.categoryText,
                  selectedCategoryId === -1 && styles.categoryTextActive,
                ]}
              >
                {t("common.recommendations")}
              </Text>
            </TouchableOpacity>
            
            {/* å…¶ä»–åˆ†ç±» */}
            {categories.map((cat) => (
              <TouchableOpacity
                key={cat.category_id}
                style={[
                  styles.categoryItem,
                  selectedCategoryId === cat.category_id &&
                    styles.categoryItemActive,
                ]}
                onPress={() => handleCategoryChange(cat.category_id)}
                onLayout={(event) => handleCategoryLayout(cat.category_id, event)}
              >
                <Text
                  style={[
                    styles.categoryText,
                    selectedCategoryId === cat.category_id &&
                      styles.categoryTextActive,
                  ]}
                >
                  {getCategoryName(cat)}
                </Text>
              </TouchableOpacity>
            ))}
          </ScrollView>
          
          {/* æ¸å˜é®ç½© */}
          <LinearGradient
            colors={['rgba(255, 255, 255, 0)', 'rgba(255, 255, 255, 1)']}
            start={{ x: 0, y: 0 }}
            end={{ x: 1, y: 0 }}
            style={styles.categoryFadeOverlay}
            pointerEvents="none"
          />
          
          {/* æŸ¥çœ‹å…¨éƒ¨æŒ‰é’® */}
          <TouchableOpacity
            style={styles.viewAllButton}
            onPress={() => setShowCategoryModal(true)}
          >
            <IconComponent
              name="chevron-down-outline"
              size={25}
              color="#666"
            />
          </TouchableOpacity>
        </View>
      </View>
    ),
    [categories, selectedCategoryId, t],
  );

  // æ¸²æŸ“å­åˆ†ç±»åŒºåŸŸ
  const renderSubcategorySection = useMemo(() => {
    if (selectedCategoryId === 0 || selectedCategoryId === -1) return null;

    if (subcategoriesLoading) {
      return (
        <View style={styles.subcategoryContainer}>
          <View
            style={{
              flex: 1,
              justifyContent: "center",
              alignItems: "center",
              height: "100%",
            }}
          >
            <ActivityIndicator size="small" color="#FF5100" />
          </View>
        </View>
      );
    }

    if (subcategories.length === 0) return null;

    const renderSubcategoryItem = (item: any) => {
      // è·å–ç±»ç›®å›¾ç‰‡æºï¼ˆæœ¬åœ°ä¼˜å…ˆï¼Œç½‘ç»œå¤‡ç”¨ï¼‰
      const imageSource = getCategoryImageSource(item.category_id, item.image, item.name);
      
      return (
        <TouchableOpacity
          key={item.category_id}
          style={styles.subcategoryItem}
          onPress={() => {
            navigation.navigate("SearchResult", {
              category_id: item.category_id,
            });
          }}
        >
          <View style={styles.subcategoryImagePlaceholder}>
            {imageSource ? (
              <Image
                source={imageSource}
                style={{ width: 40, height: 40, borderRadius: 20 }}
              />
            ) : (
              <IconComponent name="grid-outline" size={20} color="#666" />
            )}
          </View>
          <Text
            style={styles.subcategoryText}
            numberOfLines={2}
            ellipsizeMode="tail"
          >
            {item.name}
          </Text>
        </TouchableOpacity>
      );
    };

    const renderShowAllButton = () => (
      <TouchableOpacity
        key="show-all"
        style={styles.subcategoryItem}
        onPress={() => setShowAllSubcategories(!showAllSubcategories)}
      >
        <View style={styles.subcategoryImagePlaceholder}>
          <IconComponent 
            name={showAllSubcategories ? "chevron-up-outline" : "chevron-forward-outline"} 
            size={24} 
            color="#000000" 
          />
        </View>
        <Text style={[styles.subcategoryText, { color: "#000000" }]}>
          {showAllSubcategories ? t("common.collapse") : t("common.viewAll")}
        </Text>
      </TouchableOpacity>
    );

    if (showAllSubcategories) {
      // æ˜¾ç¤ºæ‰€æœ‰åˆ†ç±»ï¼Œæ¯è¡Œ5ä¸ªï¼Œæ”¶èµ·æŒ‰é’®æ”¾åœ¨æœ€åä¸€ä¸ªåˆ†ç±»åé¢
      const itemsPerRow = 5;
      const rows = [];
      
      for (let i = 0; i < subcategories.length; i += itemsPerRow) {
        const rowItems = subcategories.slice(i, i + itemsPerRow);
        rows.push(rowItems);
      }
      
      // åœ¨æœ€åä¸€è¡Œæ·»åŠ æ”¶èµ·æŒ‰é’®
      const lastRowIndex = rows.length - 1;
      const lastRow = rows[lastRowIndex];
      if (lastRow && lastRow.length < itemsPerRow) {
        // æœ€åä¸€è¡Œè¿˜æœ‰ç©ºé—´ï¼Œåœ¨ç°æœ‰çš„React Fragmentä¸­ç›´æ¥æ·»åŠ æ”¶èµ·æŒ‰é’®
        // ä¸éœ€è¦ä¿®æ”¹æ•°ç»„ç»“æ„
      }

      return (
        <View style={styles.subcategoryContainer}>
          <View style={styles.subcategoryContent}>
            {rows.map((row, rowIndex) => (
              <View key={rowIndex} style={styles.subcategoryRow}>
                {row.map(renderSubcategoryItem)}
                {rowIndex === lastRowIndex && renderShowAllButton()}
              </View>
            ))}
          </View>
        </View>
      );
    } else {
      const itemsPerRow = 5;
      const maxItemsWithoutShowAll = itemsPerRow * 2; // 10ä¸ª

      // å¦‚æœæ€»æ•°ä¸è¶…è¿‡10ä¸ªï¼Œç›´æ¥æ˜¾ç¤ºæ‰€æœ‰åˆ†ç±»ï¼Œä¸æ˜¾ç¤º"å…¨éƒ¨"æŒ‰é’®
      if (subcategories.length <= maxItemsWithoutShowAll) {
        const rows = [];
        for (let i = 0; i < subcategories.length; i += itemsPerRow) {
          const rowItems = subcategories.slice(i, i + itemsPerRow);
          rows.push(rowItems);
        }

        return (
          <View style={styles.subcategoryContainer}>
            <View style={styles.subcategoryContent}>
              {rows.map((row, rowIndex) => (
                <View key={rowIndex} style={styles.subcategoryRow}>
                  {row.map(renderSubcategoryItem)}
                </View>
              ))}
            </View>
          </View>
        );
      }
      
      // å¦‚æœæ€»æ•°è¶…è¿‡10ä¸ªï¼Œæ˜¾ç¤ºå‰ä¸¤æ’ï¼Œç¬¬äºŒæ’æœ€åä¸€ä¸ªä½ç½®æ”¾"å…¨éƒ¨"æŒ‰é’®
      const firstRow = subcategories.slice(0, itemsPerRow);
      const secondRowItems = subcategories.slice(itemsPerRow, itemsPerRow * 2 - 1);

      return (
        <View style={styles.subcategoryContainer}>
          <View style={styles.subcategoryContent}>
            <View style={styles.subcategoryRow}>
              {firstRow.map(renderSubcategoryItem)}
            </View>
            <View style={styles.subcategoryRow}>
              {secondRowItems.map(renderSubcategoryItem)}
              {renderShowAllButton()}
            </View>
          </View>
        </View>
      );
    }
  }, [selectedCategoryId, subcategories, subcategoriesLoading, showAllSubcategories, navigation, t]);


  return (
    <SafeAreaView style={styles.safeArea}>
      <StatusBar
        barStyle="dark-content"
        backgroundColor="#fff"
        translucent={false}
      />
      <View style={styles.safeAreaContent}>
        <View style={styles.container}>
          {/* å›ºå®šçš„æœç´¢æ å’Œåˆ†ç±»æ  */}
          <View style={styles.fixedHeader}>
            <SearchBar onCameraPress={handleCameraPress} />
            {renderCategorySection}
          </View>

            {/* ç™»å½•å¼¹çª— */}
            {showLoginModal && !userStore.user?.user_id && (
            <>
              <TouchableOpacity
                style={{
                  position: "absolute",
                  top: 0,
                  left: 0,
                  right: 0,
                  bottom: 0,
                  backgroundColor: "rgba(0,0,0,0.5)",
                  zIndex: 999,
                }}
                activeOpacity={1}
                onPress={handleDismissLoginModal}
              />
              <View
                style={{
                  position: "absolute",
                  left: 0,
                  right: 0,
                  bottom: 0,
                  backgroundColor: "#fff",
                  borderTopLeftRadius: 20,
                  borderTopRightRadius: 20,
                  paddingTop: 24,
                  paddingHorizontal: 24,
                  paddingBottom: 12,
                  zIndex: 1000,
                  alignItems: "center",
                  justifyContent: "center",
                }}
              >
                <TouchableOpacity
                  style={loginModalStyles.closeButton}
                  onPress={handleDismissLoginModal}
                >
                  <Text style={loginModalStyles.closeButtonText}>Ã—</Text>
                </TouchableOpacity>
                <Text style={loginModalStyles.title}>
                  {t("login.required", "è¯·å…ˆç™»å½•")}
                </Text>
                <Text style={loginModalStyles.subtitle}>
                  {t("login.tip", "ç™»å½•åå¯äº«å—æ›´å¤šæœåŠ¡")}
                </Text>
                <TouchableOpacity
                  style={loginModalStyles.loginButton}
                  onPress={() => {
                    handleDismissLoginModal();
                    navigation.navigate("Login");
                  }}
                >
                  <Text style={loginModalStyles.loginButtonText}>
                    {t("login.now", "ç«‹å³ç™»å½•")}
                  </Text>
                </TouchableOpacity>
              </View>
            </>
          )}

          {/* å¤šé¡µé¢å®¹å™¨ */}
          <View style={styles.scrollableContent}>
            <MultiPageContainer
              allCategories={allCategories}
              selectedCategoryId={selectedCategoryId}
              onCategoryChange={handleCategoryChange}
              getPageData={getPageData}
              onLoadMore={loadMoreData}
              onRefresh={refreshPageData}
              onProductPress={handleProductPress}
              onCameraPress={handleCameraPress}
              userStore={memoizedUserStore}
              t={t}
              subcategories={subcategories}
              subcategoriesLoading={subcategoriesLoading}
              onSubcategoryPress={handleSubcategoryPress}
              onViewAllSubcategories={handleViewAllSubcategories}
            />
          </View>

          {/* å›¾ç‰‡é€‰æ‹©å¼¹çª— */}
          {showImagePickerModal && (
            <>
              <TouchableOpacity
                style={{
                  position: "absolute",
                  top: 0,
                  left: 0,
                  right: 0,
                  bottom: 0,
                  backgroundColor: "rgba(0,0,0,0.5)",
                  zIndex: 999,
                }}
                activeOpacity={1}
                onPress={() => setShowImagePickerModal(false)}
              />
              <View
                style={{
                  position: "absolute",
                  left: 0,
                  right: 0,
                  bottom: 0,
                  backgroundColor: "#fff",
                  borderTopLeftRadius: 20,
                  borderTopRightRadius: 20,
                  paddingTop: 12,
                  paddingHorizontal: 20,
                  paddingBottom: 2,
                  zIndex: 1000,
                }}
              >
                {!galleryUsed ? (
                  <TouchableOpacity
                    style={styles.imagePickerOption}
                    onPress={handleTakePhoto}
                  >
                    <IconComponent
                      name="camera-outline"
                      size={24}
                      color="#333"
                    />
                    <Text style={styles.imagePickerText}>
                      {t("homePage.takePhoto")}
                    </Text>
                  </TouchableOpacity>
                ) : (
                  <TouchableOpacity
                    style={styles.imagePickerOption}
                    onPress={resetAppState}
                  >
                    <IconComponent
                      name="refresh-outline"
                      size={24}
                      color="#333"
                    />
                    <Text style={styles.imagePickerText}>é‡ç½®ç›¸æœºåŠŸèƒ½</Text>
                  </TouchableOpacity>
                )}
                <View style={styles.imagePickerDivider} />
                <TouchableOpacity
                  style={styles.imagePickerOption}
                  onPress={handleChooseFromGallery}
                >
                  <IconComponent name="images-outline" size={24} color="#333" />
                  <Text style={styles.imagePickerText}>
                    {t("homePage.chooseFromGallery")}
                  </Text>
                </TouchableOpacity>
                <View style={styles.imagePickerDivider} />
                <TouchableOpacity
                  style={styles.imagePickerCancelButton}
                  onPress={() => setShowImagePickerModal(false)}
                >
                  <Text style={styles.imagePickerCancelText}>
                    {t("homePage.cancel")}
                  </Text>
                </TouchableOpacity>
              </View>
            </>
          )}

          {/* åˆ†ç±»é€‰æ‹©å¼¹çª— */}
          {showCategoryModal && (
            <>
              <TouchableOpacity
                style={{
                  position: "absolute",
                  top: 0,
                  left: 0,
                  right: 0,
                  bottom: 0,
                  backgroundColor: "rgba(0,0,0,0.5)",
                  zIndex: 999,
                }}
                activeOpacity={1}
                onPress={() => setShowCategoryModal(false)}
              />
              <View
                style={{
                  position: "absolute",
                  left: 0,
                  right: 0,
                  bottom: 0,
                  backgroundColor: "#fff",
                  borderTopLeftRadius: 20,
                  borderTopRightRadius: 20,
                  height: "70%",
                  zIndex: 1000,
                }}
              >
                <View
                  style={{
                    paddingHorizontal: 20,
                    paddingVertical: 12,
                    borderBottomWidth: 1,
                    borderBottomColor: "#f0f0f0",
                    flexDirection: "row",
                    justifyContent: "center",
                    alignItems: "center",
                  }}
                >
                  <Text
                    style={{
                      fontSize: 18,
                      fontWeight: "600",
                      color: "#333",
                    }}
                  >
                    {t("common.allCategories")}
                  </Text>
                  <TouchableOpacity
                    onPress={() => setShowCategoryModal(false)}
                    style={{
                      position: "absolute",
                      right: 20,
                      width: 24,
                      height: 24,
                      alignItems: "center",
                      justifyContent: "center",
                    }}
                  >
                    <IconComponent name="close-outline" size={20} color="#666" />
                  </TouchableOpacity>
                </View>
                
                <ScrollView
                  style={{
                    flex: 1,
                  }}
                  contentContainerStyle={{
                    paddingBottom: 20,
                  }}
                  showsVerticalScrollIndicator={false}
                >
                  {/* æ¨èé€‰é¡¹ */}
                  <TouchableOpacity
                    style={{
                      paddingHorizontal: 20,
                      paddingVertical: 18,
                      borderBottomWidth: 1,
                      borderBottomColor: "#f0f0f0",
                      flexDirection: "row",
                      justifyContent: "space-between",
                      alignItems: "center",
                    }}
                    onPress={() => {
                      handleCategoryChange(-1);
                      setShowCategoryModal(false);
                    }}
                  >
                    <Text
                      style={{
                        fontSize: 16,
                        color: "#333",
                        fontWeight: "normal",
                      }}
                    >
                      {t("common.recommendations")}
                    </Text>
                    {selectedCategoryId === -1 && (
                      <IconComponent
                        name="checkmark-outline"
                        size={20}
                        color="#FF5100"
                      />
                    )}
                  </TouchableOpacity>
                  
                  {/* å…¶ä»–åˆ†ç±»é€‰é¡¹ */}
                  {categories.map((category) => (
                    <TouchableOpacity
                      key={category.category_id}
                      style={{
                        paddingHorizontal: 20,
                        paddingVertical: 18,
                        borderBottomWidth: 1,
                        borderBottomColor: "#f0f0f0",
                        flexDirection: "row",
                        justifyContent: "space-between",
                        alignItems: "center",
                      }}
                      onPress={() => {
                        handleCategoryChange(category.category_id);
                        setShowCategoryModal(false);
                      }}
                    >
                      <Text
                        style={{
                          fontSize: 16,
                          color: "#333",
                          fontWeight: "normal",
                        }}
                      >
                        {category.name}
                      </Text>
                      {selectedCategoryId === category.category_id && (
                        <IconComponent
                          name="checkmark-outline"
                          size={20}
                          color="#FF5100"
                        />
                      )}
                    </TouchableOpacity>
                  ))}
                </ScrollView>
              </View>
            </>
          )}
        </View>
      </View>
    </SafeAreaView>
  );
};